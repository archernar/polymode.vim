<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Cheat Sheet</title>
  <meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
  <meta name="Googlebot" content="nofollow">
  <meta name="ROBOTS" content="NOARCHIVE">
  <meta name="GOOGLEBOT" content="NOARCHIVE">
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,user-scalable=yes">
  <meta name="description" content="Mobile friendly cheatsheet">
  <link rel="shortcut icon" sizes="32x32" href="/images/vim-cheat-sheet-icon-32.png">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet">
  <link rel='stylesheet' type='text/css'  href='cheatsheet2.css'>
  <!--
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#f93f40">
  <link rel="manifest" href="/manifest.json"> 
  <meta name="theme-color" content="#FA4949">
  -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
  <script>
       var amountScrolled = 300;
       $(window).scroll(function() {
            if ( $(window).scrollTop() > amountScrolled ) {
                 $('a.sf-back-to-top').fadeIn('slow');
            } else {
                 $('a.sf-back-to-top').fadeOut('slow');
            }
       });
       $('a.sf-back-to-top').click(function() {
            $('html, body').animate({ scrollTop: 0 }, 700);
            return false;
       });
  </script>
</head>
  <body class="en_us">
  <div class="container">
       <div class="grid-block">
       <div class="grid-1">
           <h1><a class="site-title" href="/">Cheat Sheet</a></h1><br>
           <a href='#Global'>Global</a>&nbsp&nbsp;
           <a href='#CursorMovement'>Cursor Movement</a>&nbsp&nbsp;
           <a href='#Editing'>Editing</a>&nbsp&nbsp;
           <a href='#Folding'>Folding</a>&nbsp&nbsp;
           <a href='#CutPaste'>Cut and Paste</a>&nbsp&nbsp;
           <a href='#MarkingText'>Marking Text</a>&nbsp&nbsp;
           <a href='#VisualCommands'>Visual Commands</a>&nbsp&nbsp;
           <a href='#Registers'>Registers</a>&nbsp&nbsp;
           <a href='#InsertMode'>Insert Mode</a>&nbsp&nbsp;
           <a href='#Marks'>Marks</a>&nbsp&nbsp;
           <a href='#Tabs'>Tabs</a>&nbsp&nbsp;
           <a href='#Files'>Files</a>&nbsp&nbsp;
           <a href='#Search'>Search</a>&nbsp&nbsp;
           <a href='#Macros'>Macros</a>&nbsp&nbsp;
           <a href='#AutoCommands'>Auto-Commands</a>&nbsp&nbsp;
           <a href='#Exiting'>Exiting</a>&nbsp&nbsp;
           <a href='#ksh'>KornShell</a>&nbsp&nbsp;
           <a href='#kshvars'>Kshvars</a>&nbsp&nbsp;
           <a href='#gawkvars'>Gawkvars</a>&nbsp&nbsp;
           <a href="#" class="sf-back-to-top"><span class="arrow"></span>Top</a>
       </div>
       </div> <!-- end row -->

    <div class="commands-container">
      <div class="grid-block">
        <div class="grid-lg-1-3">
          <a name='Global'></a>
          <h2>Global</h2>
          <ul>
            <li><kbd>:help keyword</kbd> - open help for keyword</li>
            <li><kbd>:o file</kbd> - open file</li>
            <li><kbd>:saveas file</kbd> - save file as</li>
            <li><kbd>:close</kbd> - close current pane</li>
            <li><kbd>K</kbd> - open man page for word under the cursor</li>
          </ul>
          <a name='CursorMovement'></a>
          <h2>Cursor movement</h2>
          <ul>
            <li><kbd>h</kbd> - move cursor left</li>
            <li><kbd>j</kbd> - move cursor down</li>
            <li><kbd>k</kbd> - move cursor up</li>
            <li><kbd>l</kbd> - move cursor right</li>
            <li><kbd>H</kbd> - move to top of screen</li>
            <li><kbd>M</kbd> - move to middle of screen</li>
            <li><kbd>L</kbd> - move to bottom of screen</li>
            <li><kbd>w</kbd> - jump forwards to the start of a word</li>
            <li><kbd>W</kbd> - jump forwards to the start of a word (words can contain punctuation)</li>
            <li><kbd>e</kbd> - jump forwards to the end of a word</li>
            <li><kbd>E</kbd> - jump forwards to the end of a word (words can contain punctuation)</li>
            <li><kbd>b</kbd> - jump backwards to the start of a word</li>
            <li><kbd>B</kbd> - jump backwards to the start of a word (words can contain punctuation)</li>
            <li><kbd>%</kbd> - move to matching character (default supported pairs: '()', '{}', '[]' - use <code>:h matchpairs</code> in vim for more info)</li>
            <li><kbd>0</kbd> - jump to the start of the line</li>
            <li><kbd>^</kbd> - jump to the first non-blank character of the line</li>
            <li><kbd>$</kbd> - jump to the end of the line</li>
            <li><kbd>g_</kbd> - jump to the last non-blank character of the line</li>
            <li><kbd>gg</kbd> - go to the first line of the document</li>
            <li><kbd>G</kbd> - go to the last line of the document</li>
            <li><kbd>5G</kbd> - go to line 5</li>
            <li><kbd>fx</kbd> - jump to next occurrence of character x</li>
            <li><kbd>tx</kbd> - jump to before next occurrence of character x</li>
            <li><kbd>Fx</kbd> - jump to previous occurence of character x</li>
            <li><kbd>Tx</kbd> - jump to after previous occurence of character x</li>
            <li><kbd>;</kbd> - repeat previous f, t, F or T movement</li>
            <li><kbd>,</kbd> - repeat previous f, t, F or T movement, backwards</li>
            <li><kbd>}</kbd> - jump to next paragraph (or function/block, when editing code)</li>
            <li><kbd>{</kbd> - jump to previous paragraph (or function/block, when editing code)</li>
            <li><kbd>zz</kbd> - center cursor on screen</li>
            <li><kbd>Ctrl</kbd> + <kbd>b</kbd> - move back one full screen</li>
            <li><kbd>Ctrl</kbd> + <kbd>f</kbd> - move forward one full screen</li>
            <li><kbd>Ctrl</kbd> + <kbd>d</kbd> - move forward 1/2 a screen</li>
            <li><kbd>Ctrl</kbd> + <kbd>u</kbd> - move back 1/2 a screen</li>
          </ul>
          <div class="well">
            <strong>Tip</strong> Prefix a cursor movement command with a number to repeat it. For example, <kbd>4j</kbd> moves down 4 lines.
          </div>

          <a name='Folding'></a>
          <h2>Folding</h2>
          <ul>
              <li><kbd>zi</kbd> - switch folding on or off</li>
              <li><kbd>za</kbd> - toggle current fold open/closed</li>
              <li><kbd>zc</kbd> - close current fold</li>
              <li><kbd>zR</kbd> - open all folds</li>
              <li><kbd>zM</kbd> - close all folds</li>
              <li><kbd>zv</kbd> - expand folds to reveal cursor</li>
              <li><kbd>zo</kbd> - open current fold</li>          
              <li><kbd>zO</kbd> - recursively open current fold</li>          
              <li><kbd>zc</kbd> - close current fold</li>          
              <li><kbd>zC</kbd> - recursively close current fold</li>          
              <li><kbd>za</kbd> - toggle current fold</li>          
              <li><kbd>zA</kbd> - recursively open/close current fold</li>          
              <li><kbd>zm</kbd> - reduce `foldlevel` by one</li>          
              <li><kbd>zM</kbd> - close all folds</li>          
              <li><kbd>zr</kbd> - increase `foldlevel` by one</li>          
              <li><kbd>zR</kbd> - open all folds</li>          
          </ul>
          <div class="well">
          <ul>
              <strong>On UnFolded Buffers</strong>
              <li><kbd>zj</kbd> - move down to top of next fold</li>
              <li><kbd>zk</kbd> - move up to bottom of previous fold</li>
          </ul>
          </div>
          <a name='InsertMode'></a>
          <h2>Insert mode - inserting/appending text</h2>
          <ul>
            <li><kbd>i</kbd> - insert before the cursor</li>
            <li><kbd>I</kbd> - insert at the beginning of the line</li>
            <li><kbd>a</kbd> - insert (append) after the cursor</li>
            <li><kbd>A</kbd> - insert (append) at the end of the line</li>
            <li><kbd>o</kbd> - append (open) a new line below the current line</li>
            <li><kbd>O</kbd> - append (open) a new line above the current line</li>
            <li><kbd>ea</kbd> - insert (append) at the end of the word</li>
            <li><kbd>Esc</kbd> - exit insert mode</li>
          </ul>
        </div>
      <!-- ------------------------------------------------------------------------------------------------------------ -->
      <!-- End of First Column -->
      <!-- ------------------------------------------------------------------------------------------------------------ -->


        <div class="grid-lg-1-3">
          <a name='Editing'></a>
          <h2>Editing</h2>
          <ul>
            <li><kbd>r</kbd> - replace a single character</li>
            <li><kbd>J</kbd> - join line below to the current one with one space in between</li>
            <li><kbd>gJ</kbd> - join line below to the current one without space in between</li>
            <li><kbd>cc</kbd> - change (replace) entire line</li>
            <li><kbd>cw</kbd> - change (replace) to the end of the word</li>
            <li><kbd>c$</kbd> - change (replace) to the end of the line</li>
            <li><kbd>s</kbd> - delete character and substitute text</li>
            <li><kbd>S</kbd> - delete line and substitute text (same as cc)</li>
            <li><kbd>xp</kbd> - transpose two letters (delete and paste)</li>
            <li><kbd>u</kbd> - undo</li>
            <li><kbd>Ctrl</kbd> + <kbd>r</kbd> - redo</li>
            <li><kbd>.</kbd> - repeat last command</li>
          </ul>
          <a name='MarkingText'></a>
          <h2>Marking text (visual mode)</h2>
          <ul>
            <li><kbd>v</kbd> - start visual mode, mark lines, then do a command (like y-yank)</li>
            <li><kbd>V</kbd> - start linewise visual mode</li>
            <li><kbd>o</kbd> - move to other end of marked area</li>
            <li><kbd>Ctrl</kbd> + <kbd>v</kbd> - start visual block mode</li>
            <li><kbd>O</kbd> - move to other corner of block</li>
            <li><kbd>aw</kbd> - mark a word</li>
            <li><kbd>ab</kbd> - a block with ()</li>
            <li><kbd>aB</kbd> - a block with {}</li>
            <li><kbd>ib</kbd> - inner block with ()</li>
            <li><kbd>iB</kbd> - inner block with {}</li>
            <li><kbd>Esc</kbd> - exit visual mode</li>
          </ul>
          <a name='VisualCommands'></a>
          <h2>Visual commands</h2>
          <ul>
            <li><kbd>&#62;</kbd> - shift text right</li>
            <li><kbd>&#60;</kbd> - shift text left</li>
            <li><kbd>y</kbd> - yank (copy) marked text</li>
            <li><kbd>d</kbd> - delete marked text</li>
            <li><kbd>~</kbd> - switch case</li>
          </ul>
          <a name='Registers'></a>
          <h2>Registers</h2>
          <ul>
            <li><kbd>:reg</kbd> - show registers content</li>
            <li><kbd>"xy</kbd> - yank into register x</li>
            <li><kbd>"xp</kbd> - paste contents of register x</li>
          </ul>
          <div class="well">
            <strong>Tip</strong> Registers are being stored in ~/.viminfo, and will be loaded again on next restart of vim.
          </div>
          <div class="well">
            <strong>Tip</strong> Register 0 contains always the value of the last yank command.
          </div>

          <a name='Marks'></a>
          <h2>Marks</h2>
          <ul>
            <li><kbd>:marks</kbd> - list of marks</li>
            <li><kbd>ma</kbd> - set current position for mark A</li>
            <li><kbd>`a</kbd> - jump to position of mark A</li>
            <li><kbd>y`a</kbd> - yank text to position of mark A</li>
          </ul>
          <a name='Macros'></a>
          <h2>Macros</h2>
          <ul>
            <li><kbd>qa</kbd> - record macro a</li>
            <li><kbd>q</kbd> - stop recording macro</li>
            <li><kbd>@a</kbd> - run macro a</li>
            <li><kbd>@@</kbd> - rerun last run macro</li>
          </ul>
          <a name='CutPaste'></a>
          <h2>Cut and paste</h2>
          <ul>
            <li><kbd>yy</kbd> - yank (copy) a line</li>
            <li><kbd>2yy</kbd> - yank (copy) 2 lines</li>
            <li><kbd>yw</kbd> - yank (copy) the characters of the word from the cursor position to the start of the next word</li>
            <li><kbd>y$</kbd> - yank (copy) to end of line</li>
            <li><kbd>p</kbd> - put (paste) the clipboard after cursor</li>
            <li><kbd>P</kbd> - put (paste) before cursor</li>
            <li><kbd>dd</kbd> - delete (cut) a line</li>
            <li><kbd>2dd</kbd> - delete (cut) 2 lines</li>
            <li><kbd>dw</kbd> - delete (cut) the characters of the word from the cursor position to the start of the next word</li>
            <li><kbd>D</kbd> - delete (cut) to the end of the line</li>
            <li><kbd>d$</kbd> - delete (cut) to the end of the line</li>
            <li><kbd>x</kbd> - delete (cut) character</li>
          </ul>
          <a name='Exiting'></a>
          <h2>Exiting</h2>
          <ul>
            <li><kbd>:w</kbd> - write (save) the file, but don't exit</li>
            <li><kbd>:w !sudo tee %</kbd> - write out the current file using sudo</li>
            <li><kbd>:wq</kbd> or <kbd>:x</kbd> or <kbd>ZZ</kbd> - write (save) and quit</li>
            <li><kbd>:q</kbd> - quit (fails if there are unsaved changes)</li>
            <li><kbd>:q!</kbd> or <kbd>ZQ</kbd> - quit and throw away unsaved changes</li>
            <li><kbd>:wqa</kbd> - write (save) and quit on all tabs</li>
          </ul>
        </div>
        <!-- ------------------------------------------------------------------------------------------------------------ -->
        <!-- End of Second Column -->
        <!-- ------------------------------------------------------------------------------------------------------------ -->

        <div class="grid-lg-1-3">
          <a name='Search'></a>
          <h2>Search and Replace</h2>
          <ul>
            <li><kbd>/pattern</kbd> - search for pattern</li>
            <li><kbd>?pattern</kbd> - search backward for pattern</li>
            <li><kbd>\vpattern</kbd> - 'very magic' pattern: non-alphanumeric chars are interpreted as special regex symbols (no escaping needed)</li>
            <li><kbd>n</kbd> - repeat search in same direction</li>
            <li><kbd>N</kbd> - repeat search in opposite direction</li>
            <li><kbd>:s/old/new</kbd> - replace next occurence of old with new</li>
            <li><kbd>:s/old/new/g</kbd> - replace all occurences on a line</li>
            <li><kbd>:%s/old/new/g</kbd> - replace all old with new throughout file</li>
            <li><kbd>:%s/old/new/gc</kbd> - replace all old with new throughout file with confirmations</li>
            <li><kbd>:noh</kbd> - remove highlighting of search matches</li>
          </ul>
          <h2>Search in multiple files</h2>
          <ul>
            <li><kbd>:vimgrep /pattern/ {file}</kbd> - search for pattern in multiple files</li>
          </ul>
          <div class="well">
            e.g.
            <kbd>:vimgrep /foo/ **/*</kbd>
          </div>
          <ul>
            <li><kbd>:cn</kbd> - jump to the next match</li>
            <li><kbd>:cp</kbd> - jump to the previous match</li>
            <li><kbd>:copen</kbd> - open a window containing the list of matches</li>
          </ul>
          <a name='Files'></a>
          <h2>Working with multiple files</h2>
          <ul>
            <li><kbd>:e file</kbd> - edit a file in a new buffer</li>
            <li><kbd>:bnext</kbd> or <kbd>:bn</kbd> - go to the next buffer</li>
            <li><kbd>:bprev</kbd> or <kbd>:bp</kbd> - go to the previous buffer</li>
            <li><kbd>:bd</kbd> - delete a buffer (close a file)</li>
            <li><kbd>:ls</kbd> - list all open buffers</li>
            <li><kbd>:sp file</kbd> - open a file in a new buffer and split window</li>
            <li><kbd>:vsp file</kbd> - open a file in a new buffer and vertically split window</li>
            <li><kbd>Ctrl</kbd> + <kbd>ws</kbd> - split window</li>
            <li><kbd>Ctrl</kbd> + <kbd>ww</kbd> - switch windows</li>
            <li><kbd>Ctrl</kbd> + <kbd>wq</kbd> - quit a window</li>
            <li><kbd>Ctrl</kbd> + <kbd>wv</kbd> - split window vertically</li>
            <li><kbd>Ctrl</kbd> + <kbd>wh</kbd> - move cursor to the left window (vertical split)</li>
            <li><kbd>Ctrl</kbd> + <kbd>wl</kbd> - move cursor to the right window (vertical split)</li>
            <li><kbd>Ctrl</kbd> + <kbd>wj</kbd> - move cursor to the window below (horizontal split)</li>
            <li><kbd>Ctrl</kbd> + <kbd>wk</kbd> - move cursor to the window above (horizontal split)</li>
          </ul>
          <a name='AutoCommands'></a>
          <h2>Auto Commands Reading</h2>
          <ul>
          <li><i>RAF=read a file, RTF=read the file, R=reading</i></li>
          <li><kbd>BufNewFile</kbd>	starting to edit a file that doesn't exist</li>
          <li><kbd>BufReadPre</kbd>	starting to edit a new buffer, before RTF</li>
          <li><kbd>BufRead</kbd>	starting to edit a new buffer, after RTF</li>
          <li><kbd>BufReadPost</kbd>	starting to edit a new buffer, after RTF</li>
          <li><kbd>BufReadCmd</kbd>	before starting to edit a new buffer |Cmd-event|</li>
          <li><kbd>FileReadPre</kbd>	before RAF with a ":read"</li>
          <li><kbd>FileReadPost</kbd>	after RAF with ":read"</li>
          <li><kbd>FileReadCmd</kbd>	before RAF with ":read" |Cmd-event|</li>
          <li><kbd>FilterReadPre</kbd>	before RAF from a filter Cmd</li>
          <li><kbd>FilterReadPost</kbd>	after RAF from a filter Cmd</li>
          <li><kbd>StdinReadPre</kbd>	before R from stdin into the buffer</li>
          <li><kbd>StdinReadPost</kbd>	After R from the stdin into the buffer</li>
          </ul>
          <a name='Tabs'></a>
          <h2>Tabs</h2>
          <ul>
            <li><kbd>:tabnew</kbd> or <kbd>:tabnew file</kbd> - open a file in a new tab</li>
            <li><kbd>Ctrl</kbd> + <kbd>wT</kbd> - move the current split window into its own tab</li>
            <li><kbd>gt</kbd> or <kbd>:tabnext</kbd> or <kbd>:tabn</kbd> - move to the next tab</li>
            <li><kbd>gT</kbd> or <kbd>:tabprev</kbd> or <kbd>:tabp</kbd> - move to the previous tab</li>
            <li><kbd>#gt</kbd> - move to tab number #</li>
            <li><kbd>:tabmove #</kbd> - move current tab to the #th position (indexed from 0)</li>
            <li><kbd>:tabclose</kbd> or <kbd>:tabc</kbd> - close the current tab and all its windows</li>
            <li><kbd>:tabonly</kbd> or <kbd>:tabo</kbd> - close all tabs except for the current one</li>
            <li><kbd>:tabdo</kbd> command - run the <code>command</code> on all tabs (e.g. <code>:tabdo q</code> - closes all opened tabs)</li>
          </ul>
        <a name='ksh'></a>
        <h2>Korn Shell</h2>
        <div class="well">
            <font size='-2'>
            <code>
              #!/usr/bin/ksh<br>
              Tmp="/tmp/$$"<br>
              TmpDir="/tmp/dir$$"<br>
              trap 'rm -f "$Tmp" >/dev/null 2>&1' 0<br>
              trap "exit 2" 1 2 3 13 15<br>
              rm $Tmp  >/dev/null 2>&1<br>
            </code>
            </font>
        </div>

        <div class="well">
            <font size='-2'>
            <code>
                if [[ $name = "John" ]];then<br>
                # commands....<br>
                fi<br>
                if [[ $size -eq 1000 ]];then<br>
                # commands....<br>
                fi<br>
                <ul>
                <li><kbd>$1 - $9</kbd>      these variables are the positional parameters.</li>
                <li><kbd>$0</kbd>            the name of the command currently being executed.</li>
                <li><kbd>$argv[20]</kbd>     refers to the 20th command line argument</li>
                <li><kbd>$#</kbd>            the number of positional arguments given to this invocation of the shell.</li>
                <li><kbd>$?</kbd>            the exit status of the last command executed is given as a decimal string.  When a command
                completes successfully, it returns the exit status of 0 (zero), otherwise it returns a non-zero exit status.</li>
                <li><kbd>$$</kbd>            the process number of this shell - useful for including in filenames, to make them unique.</li>
                <li><kbd>$!</kbd>            the process id of the last command run in the background.</li>
                <li><kbd>$-</kbd>            the current options supplied to this invocation of the shell.</li>
                <li><kbd>$*</kbd>            a string containing all the arguments to the shell, starting at $1.</li>
                <li><kbd>$@</kbd>            same as above, except when quoted :<br>
                                             "$*" expanded into ONE long element : "$1 $2 $3"<br>
                                             "$@" expanded into THREE elements : "$1" "$2" "$3"</li>
                <li><kbd>shift</kbd>   : $2 -> $1 ...)</li>
                </ul>


                <a name='gawkvars'></a>
                <h2>Gawk Variables</h2>
<pre>
Gawk Built-in Variables

ARGC        The number of command line arguments (does not include
            options to gawk, or the program source).

ARGIND      The index in ARGV of the current file being processed.

ARGV        Array of command line arguments.  The array is indexed
            from 0 to ARGC - 1.  Dynamically changing the contents of
            ARGV can control the files used for data.

FS          The input field separator, a space by default.  See
            Fields, above.

NF          The number of fields in the current input record.

NR          The total number of input records seen so far.

OFMT        The output format for numbers, "%.6g", by default.

OFS         The output field separator, a space by default.

ORS         The output record separator, by default a newline.

RS          The input record separator, by default a newline.


BINMODE     On non-POSIX systems, specifies use of “binary” mode for
            all file I/O.  Numeric values of 1, 2, or 3, specify that
            input files, output files, or all files, respectively,
            should use binary I/O.  String values of "r", or "w"
            specify that input files, or output files, respectively,
            should use binary I/O.  String values of "rw" or "wr"
            specify that all files should use binary I/O.  Any other
            string value is treated as "rw", but generates a warning
            message.

CONVFMT     The conversion format for numbers, "%.6g", by default.

ENVIRON     An array containing the values of the current
            environment.  The array is indexed by the environment
            variables, each element being the value of that variable
            (e.g., ENVIRON["HOME"] might be "/home/arnold").

            In POSIX mode, changing this array does not affect the
            environment seen by programs which gawk spawns via
            redirection or the system() function.  Otherwise, gawk
            updates its real environment so that programs it spawns
            see the changes.

ERRNO       If a system error occurs either doing a redirection for
            getline, during a read for getline, or during a close(),
            then ERRNO is set to a string describing the error.  The
            value is subject to translation in non-English locales.
            If the string in ERRNO corresponds to a system error in
            the errno(3) variable, then the numeric value can be
            found in PROCINFO["errno"].  For non-system errors,
            PROCINFO["errno"] will be zero.

FIELDWIDTHS A whitespace-separated list of field widths.  When set,
            gawk parses the input into fields of fixed width, instead
            of using the value of the FS variable as the field
            separator.  Each field width may optionally be preceded
            by a colon-separated value specifying the number of
            characters to skip before the field starts.  See Fields,
            above.

FILENAME    The name of the current input file.  If no files are
            specified on the command line, the value of FILENAME is
            “-”.  However, FILENAME is undefined inside the BEGIN
            rule (unless set by getline).

FNR         The input record number in the current input file.

FPAT        A regular expression describing the contents of the
            fields in a record.  When set, gawk parses the input into
            fields, where the fields match the regular expression,
            instead of using the value of the FS variable as the
            field separator.  See Fields, above.

FUNCTAB     An array whose indices and corresponding values are the
            names of all the user-defined or extension functions in
            the program.  NOTE: You may not use the delete statement
            with the FUNCTAB array.

IGNORECASE  Controls the case-sensitivity of all regular expression
            and string operations.  If IGNORECASE has a non-zero
            value, then string comparisons and pattern matching in
            rules, field splitting with FS and FPAT, record
            separating with RS, regular expression matching with ~
            and !~, and the gensub(), gsub(), index(), match(),
            patsplit(), split(), and sub() built-in functions all
            ignore case when doing regular expression operations.
            NOTE: Array subscripting is not affected.  However, the
            asort() and asorti() functions are affected.
            Thus, if IGNORECASE is not equal to zero, /aB/ matches
            all of the strings "ab", "aB", "Ab", and "AB".  As with
            all AWK variables, the initial value of IGNORECASE is
            zero, so all regular expression and string operations are
            normally case-sensitive.

LINT        Provides dynamic control of the --lint option from within
            an AWK program.  When true, gawk prints lint warnings.
            When false, it does not.  When assigned the string value
            "fatal", lint warnings become fatal errors, exactly like
            --lint=fatal.  Any other true value just prints warnings.

PREC        The working precision of arbitrary precision floating-
            point numbers, 53 by default.

PROCINFO    The elements of this array provide access to information
            about the running AWK program.  On some systems, there
            may be elements in the array, "group1" through "groupn"
            for some n, which is the number of supplementary groups
            that the process has.  Use the in operator to test for
            these elements.  The following elements are guaranteed to
            be available:

            PROCINFO["argv"]     The command line arguments as
                                 received by gawk at the C-language
                                 level.  The subscripts start from
                                 zero.

            PROCINFO["egid"]     The value of the getegid(2) system
                                 call.

            PROCINFO["errno"]    The value of errno(3) when ERRNO is
                                 set to the associated error message.

            PROCINFO["euid"]     The value of the geteuid(2) system
                                 call.

            PROCINFO["FS"]       "FS" if field splitting with FS is
                                 in effect, "FPAT" if field splitting
                                 with FPAT is in effect,
                                 "FIELDWIDTHS" if field splitting
                                 with FIELDWIDTHS is in effect, or
                                 "API" if API input parser field
                                 splitting is in effect.

            PROCINFO["gid"]      The value of the getgid(2) system
                                 call.

            PROCINFO["identifiers"]
                   A subarray, indexed by the names of
                   all identifiers used in the text of
                   the AWK program.  The values
                   indicate what gawk knows about the
                   identifiers after it has finished
                   parsing the program; they are not
                   updated while the program runs.  For
                   each identifier, the value of the
                   element is one of the following:

                   "array"     The identifier is an
                               array.

                   "builtin"   The identifier is a
                               built-in function.

                   "extension" The identifier is an
                               extension function
                               loaded via @load or -l.

                   "scalar"    The identifier is a
                               scalar.

                   "untyped"   The identifier is
                               untyped (could be used
                               as a scalar or array,
                               gawk doesn't know yet).

                   "user"      The identifier is a
                               user-defined function.

            PROCINFO["pgrpid"]   The process group ID of the current
                                 process.

            PROCINFO["pid"]      The process ID of the current
                                 process.

            PROCINFO["ppid"]     The parent process ID of the current
                                 process.

            PROCINFO["strftime"] The default time format string for
                                 strftime().

            PROCINFO["uid"]      The value of the getuid(2) system
                                 call.

            PROCINFO["version"]  the version of gawk.

            The following elements are present if loading dynamic
            extensions is available:

            PROCINFO["api_major"]
                   The major version of the extension API.

            PROCINFO["api_minor"]
                   The minor version of the extension API.

            The following elements are available if MPFR support is
            compiled into gawk:

            PROCINFO["gmp_version"]
                   The version of the GNU MP library used for
                   arbitrary precision number support in gawk.

            PROCINFO["mpfr_version"]
                   The version of the GNU MPFR library used for
                   arbitrary precision number support in gawk.

            PROCINFO["prec_max"]
                   The maximum precision supported by the GNU MPFR
                   library for arbitrary precision floating-point
                   numbers.

            PROCINFO["prec_min"]
                   The minimum precision allowed by the GNU MPFR
                   library for arbitrary precision floating-point
                   numbers.

            The following elements may set by a program to change
            gawk's behavior:

            PROCINFO["NONFATAL"]
                   If this exists, then I/O errors for all output
                   redirections become nonfatal.

            PROCINFO["output_name", "NONFATAL"]
                   Make output errors for output_name be nonfatal.

            PROCINFO["command", "pty"]
                   Use a pseudo-tty for two-way communication with
                   command instead of setting up two one-way pipes.

            PROCINFO["input", "READ_TIMEOUT"]
                   The timeout in milliseconds for reading data from
                   input, where input is a redirection string or a
                   filename. A value of zero or less than zero means
                   no timeout.

            PROCINFO["input", "RETRY"]
                   If an I/O error that may be retried occurs when
                   reading data from input, and this array entry
                   exists, then getline returns -2 instead of
                   following the default behavior of returning -1 and
                   configuring input to return no further data.  An
                   I/O error that may be retried is one where
                   errno(3) has the value EAGAIN, EWOULDBLOCK, EINTR,
                   or ETIMEDOUT.  This may be useful in conjunction
                   with PROCINFO["input", "READ_TIMEOUT"] or
                   situations where a file descriptor has been
                   configured to behave in a non-blocking fashion.

            PROCINFO["sorted_in"]
                   If this element exists in PROCINFO, then its value
                   controls the order in which array elements are
                   traversed in for loops.  Supported values are
                   "@ind_str_asc", "@ind_num_asc", "@val_type_asc",
                   "@val_str_asc", "@val_num_asc", "@ind_str_desc",
                   "@ind_num_desc", "@val_type_desc",
                   "@val_str_desc", "@val_num_desc", and "@unsorted".
                   The value can also be the name (as a string) of
                   any comparison function defined as follows:

                        function cmp_func(i1, v1, i2, v2)

                   where i1 and i2 are the indices, and v1 and v2 are
                   the corresponding values of the two elements being
                   compared.  It should return a number less than,
                   equal to, or greater than 0, depending on how the
                   elements of the array are to be ordered.

ROUNDMODE   The rounding mode to use for arbitrary precision
            arithmetic on numbers, by default "N" (IEEE-754
            roundTiesToEven mode).  The accepted values are "N" or
            "n" for roundTiesToEven, "U" or "u" for
            roundTowardPositive, "D" or "d" for roundTowardNegative,
            "Z" or "z" for roundTowardZero, and if your version of
            GNU MPFR library supports it, "A" or "a" for rounding
            away from zero.

RT          The record terminator.  Gawk sets RT to the input text
            that matched the character or regular expression
            specified by RS.

RSTART      The index of the first character matched by match(); 0 if
            no match.  (This implies that character indices start at
            one.)

RLENGTH     The length of the string matched by match(); -1 if no
            match.

SUBSEP      The character used to separate multiple subscripts in
            array elements, by default "\034".

SYMTAB      An array whose indices are the names of all currently
            defined global variables and arrays in the program.  The
            array may be used for indirect access to read or write
            the value of a variable:

                 foo = 5
                 SYMTAB["foo"] = 4
                 print foo    # prints 4

            The typeof() function may be used to test if an element
            in SYMTAB is an array.  You may not use the delete
            statement with the SYMTAB array.

TEXTDOMAIN  The text domain of the AWK program; used to find the
            localized translations for the program's strings.
</pre>
         <a name='kshvars'></a>
         <h2>Korn Shell Variables</h2>
<pre>
Special shell variables
$1 - $9       these variables are the positional parameters.
$0            the name of the command currently being executed.
$argv[20]     refers to the 20th command line argument
$#            the number of positional arguments given to this
              invocation of the shell.
$?            the exit status of the last command executed is
              given as a decimal string.  When a command
              completes successfully, it returns the exit status
              of 0 (zero), otherwise it returns a non-zero exit
              status.
$$            the process number of this shell - useful for
              including in filenames, to make them unique.
$!            the process id of the last command run in
              the background.
$-            the current options supplied to this invocation
              of the shell.
$*            a string containing all the arguments to the
              shell, starting at $1.
$@            same as above, except when quoted :
              "$*" expanded into ONE long element : "$1 $2 $3"
              "$@" expanded into THREE elements : "$1" "$2" "$3"
shift         : $2 -> $1 ...)
</pre>
<pre>
+---------------+------------------------------------------------+
| Test          | Returns true if object...                      |
+---------------+------------------------------------------------+
| -a object     | exist; any type of object                      |
| -f object     | is a regular file or a symbolic link           |
| -d object     | is a directory                                 |
| -c object     | is a character special file                    |
| -b object     | is a block special file                        |
| -p object     | is a named pipe                                |
| -S object     | is a socket                                    |
| -L object     | is a symbolic (soft) link with another object  |
| -k object     | object's "sticky bit" is set                   |
| -s object     | object isn't empty                             |
| -r object     | I may read this object                         |
| -w object     | I may write to (modify) this object            |
| -x object     | object is an executable file                   |
|               |        or a directory I can search             |
| -O object     | I ownn this object                             |
| -G object     | the group to which I belong owns object        |
| -u object     | object's set-user-id bit is set                |
| -g object     | object's set-group-id bit is set               |
| obj1 -nt obj2 | obj1 is newer than obj2                        |
| obj1 -ot obj2 | obj1 is older than obj2                        |
| obj1 -ef obj2 | obj1 is another name for obj2 (equivalent)     |
+---------------+------------------------------------------------+
</pre>
            </code>
            </font>
        </div>


        <div class="wellcode">
<pre>
    #!/bin/ksh

    function fonc {
         echo "Loop over params, with shift function"
         for i do
             print "parameter $1"
             shift
         done
    }

    echo "Loop over all ($#) parameters : $*"
    for i do
        echo "parameter $i"
    done
    # ---------------------------------------
    # Is the first arg. a directory name ?
    if (( $# > 0 ))
    then
        dir_name=$1
    else
        print -n "Directory name:"
        read dir_name
    fi
    print "You specified the following directory; $dir_name"
    if [[ ! -d $dir_name ]]
    then
        print "Sorry, but $dir_name isn't the name of a directory"
    else
        echo "List of directory $dir_name "
        ls -l $dir_name
        echo "----------------------------"
    fi
    # ---------------------------------------
    # Loop over files in a directory
    for file in "$@"
    do
         print "$file"
    done
    # 
    # 
    echo "switch on #params"
    case $# in
        0) echo "command with no parameter";;
        1) echo "there is only one parameter : $1";;
        2) echo "there are two parameters";;
        [3,4]) echo "3 or 4 params";;
        *) echo "more than 4 params";;
    esac
    # 
    fonc
    echo "Parameters number (after function fonc) : $#"
    # To read and execute a command
    echo "==> Enter a name"
    while read com
    do
        case $com in
            tristram) echo "gerard";;
            guglielmi) echo "laurent";;
            dolbeau) echo "Jean";;
            poutot) echo "Daniel ou Claude ?";;
            lutz | frenkiel) echo "Pierre";;
            brunet) echo "You lost !!!"; exit ;;
            *) echo "Unknown guy !!! ( $com )"; break ;;
        esac
        echo "==> another name, please"
    done
    # 
    # The test function :
    echo "Enter a file name"
    read name
    if [ -r $name ]
    then echo "This file is readable"
    fi
    if [ -w $name ]
        then echo "This file is writable"
    fi
    if [ -x $name ]
        then echo "This file is executable"
    fi
    #
    echo "Menu select"
    PS3="Enter your choice: "
    select menu_list in English francais quit
    do
        case $menu_list in
            English)   print "Thank you";;
            francais)  print "Merci.";;
            quit)       break;;
            *)       print " ????";;
        esac
    done
    print "So long!"
</pre>
        </div>


        </div>

      </div>
      <!-- end grid-block -->
      <!-- ------------------------------------------------------------------------------------------------------------ -->
      <!-- End of Third Column -->
      <!-- ------------------------------------------------------------------------------------------------------------ -->


      <div class="grid-block">
        <div class="grid-lg-1-3">
        </div>
      <!-- end grid-block -->
      </div>

  </div>
</body>

</html>
